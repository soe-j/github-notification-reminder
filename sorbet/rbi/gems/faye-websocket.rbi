# This file is autogenerated. Do not edit it by hand. Regenerate it with:
#   srb rbi gems

# typed: strong
#
# If you would like to make changes to this file, great! Please create the gem's shim here:
#
#   https://github.com/sorbet/sorbet-typed/new/master?filename=lib/faye-websocket/all/faye-websocket.rbi
#
# faye-websocket-0.10.9
module Faye::WebSocket::API
  def begin_close(reason, code, options = nil); end
  def buffered_amount; end
  def close(code = nil, reason = nil); end
  def emit_error(message); end
  def finalize_close; end
  def initialize(options = nil); end
  def open; end
  def parse(data); end
  def ping(message = nil, &callback); end
  def protocol; end
  def ready_state; end
  def receive_message(data); end
  def send(message); end
  def url; end
  def version(*args, &block); end
  def write(data); end
  extend Forwardable
  include Faye::WebSocket::API::EventTarget
end
module Faye::WebSocket::API::EventTarget
  def add_event_listener(event_type, listener, use_capture = nil); end
  def add_listener(event_type, callable = nil, &block); end
  def dispatch_event(event); end
  def event_buffers; end
  def flush(event_type, listener); end
  def onclose=(handler); end
  def onerror=(handler); end
  def onmessage=(handler); end
  def onopen=(handler); end
  def remove_event_listener(event_type, listener, use_capture = nil); end
  include WebSocket::Driver::EventEmitter
end
class Faye::WebSocket::API::Event
  def bubbles; end
  def cancelable; end
  def current_target; end
  def current_target=(arg0); end
  def event_phase; end
  def event_phase=(arg0); end
  def init_event(event_type, can_bubble, cancelable); end
  def initialize(event_type, options); end
  def prevent_default; end
  def self.create(type, options = nil); end
  def stop_propagation; end
  def target; end
  def target=(arg0); end
  def type; end
end
class Faye::WebSocket::API::OpenEvent < Faye::WebSocket::API::Event
end
class Faye::WebSocket::API::MessageEvent < Faye::WebSocket::API::Event
  def data; end
end
class Faye::WebSocket::API::CloseEvent < Faye::WebSocket::API::Event
  def code; end
  def reason; end
end
class Faye::WebSocket::API::ErrorEvent < Faye::WebSocket::API::Event
  def message; end
end
module Faye
end
class Faye::WebSocket
  def env; end
  def initialize(env, protocols = nil, options = nil); end
  def rack_response; end
  def self.determine_url(env, schemes = nil); end
  def self.ensure_reactor_running; end
  def self.load_adapter(backend); end
  def self.secure_request?(env); end
  def self.websocket?(env); end
  def start_driver; end
  include Faye::WebSocket::API
end
class Faye::RackStream
  def clean_rack_hijack; end
  def close_connection; end
  def close_connection_after_writing; end
  def each(&callback); end
  def fail; end
  def hijack_rack_socket; end
  def initialize(socket); end
  def receive(data); end
  def write(data); end
  include EventMachine::Deferrable
end
module Faye::RackStream::Reader
  def receive_data(data); end
  def stream; end
  def stream=(arg0); end
  def unbind; end
end
class Faye::WebSocket::Stream < Faye::RackStream
  def fail; end
  def receive(data); end
end
